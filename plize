#!/bin/bash

function main () {
    local -
    set +e +m -f
    local NORM RED GREEN YELLOW CYAN IRED IGREEN IBLUE ICYAN IMAGENTA WHITE
    local help=0
    local dryrun=0
    local quiet=0
    local debug=0
    declare -i cpus=2
    local specfile=""
    local logfile=""
    local outputscript=""
    local topdependency=""

    parseCommandArgs "$*"
    [ "$logfile" ] || setColors

    ((help)) && help && return
    [ "$specfile" ] && { [ -e "$specfile" ] && exec <$specfile || throwInvalidFile; }

    declare -A tasks=()
    declare -A taskStates=()
    declare -A tasksTimeStarted=()
    declare -A dependencies=()
    local topsexpr="" 
    local dependencytree=("")
    readTasksAndGraph

    if ((dryrun))
    then
      ((debug)) && prettyPrintEverything
      return
    else
      if [ "$outputscript" ]
      then
        createScript
      else
        scheduler
      fi
    fi
}

########################################

function setColors () {
    NORM=$'\e[m'
    RED=$'\e[0;31m'
    GREEN=$'\e[0;32m'
    YELLOW=$'\e[0;33m'
    CYAN=$'\e[0;36m'
    IRED=$'\e[1;31m'
    IGREEN=$'\e[1;32m'
    IBLUE=$'\e[1;34m'
    ICYAN=$'\e[1;36m'
    IMAGENTA=$'\e[1;35m'
    WHITE=$'\e[1;37m'
}

function parseCommandArgs () {
    local a
    while read a
    do case $a in
      (-h) help=1 ;;
      (-d) dryrun=1 ;;
      (-q) quiet=1 ;;
      (-t) read topdependency; [ "${topdependency:0:1}" == "=" ] || topdependency="=${topdependency}" ;;
      (-v) debug=1 ;;
      (-vv) debug=2 ;;
      (-c) read cpus ;;
      (-l) read logfile ;;
      (-o) read outputscript ;;
      (*) [ a[0] != - ] && specfile=$a ;;
    esac done < <(tr " " "\n" <<<$*)
}

function help () {
    cat <<BLOCK

NAME
  Parallelize - Dependency defined bash scheduler

USAGE
  plize [-h] [-c CPUs] [-d] [-q] [-t subdep] [-v | -vv] [-l log] [-o ofile] [file]

  Reads a TASKS AND DEPENDENCIES LIST specification via STDIN if no [file]
  specified.

  Returns 0 if all tasks succeed or the error number of the failing task.
  The scheduler stops if any task fails but will not stop any already
  running tasks.

OPTIONS
  -h       Help/manual
  -c       CPU/threads/process limit
  -d       Dry run
  -q       Quiet prefixed task info for all job output
  -t subid Top dependency tree override with sub-dependency id
  -v       Verbose runtime details
  -vv      Verbose plus dependency tree details
  -l       Logfile verbose messages are appended
  -o ofile Write a standalone runable script to ofile
  file     specification file

TASKS AND DEPENDENCIES LIST Syntax:

  A list containing multiple lines of TASK DEFINITIONS,
  SUB DEPENDENCY definitions, and a main DEPENDENCY DEFINITION.

  Example 1:

# A COMMENT
task1 echo hello world
task2 git clone stuff; sleep && date
task3 cargo build | cat -n
=subtask (+ task2 task3)
(* task1 =subtask)

  Example 2:

aa echo hello
bb echo world
=sub (+ aa bb)
cc echo done
(* =sub cc)


TASK DEFINITION Syntax:

    taskId bash-expression

  A task definition is a line with two parts:  A unique task ID followed by
  a bash expression.  The bash-expression must be one line with no line
  breaks.  It may be a compound expression IE with semicolons, pipes, etc.

  The task IDs are used in the dependency tree definitions.

  Example:

    task1 sleep 1; echo hello world | xxd

SUB DEPENDENCY DEFINITION Syntax:

    =taskId dependency-definition

  A sub-dependency definition is a line with two parts:  A unique sub-task ID,
  prefied with an equals "=" character, and a DEPENDENCY DEFINITION.  SUB
  DEPENDENCIES can include other SUB DEPENDENCIES but cycles are not allowed.

  Example:

    taska echo a
    taskb echo b
    taskc echo c
    =dep1 (+ taska taskb)
    =dep2 (* dep1)
    =dep3 (* =dep1 =dep2 c)
    (+ =dep1 =dep3 c)


DEPENDENCY DEFINITION Syntax:

    sexpr

  A parenthesized prefix-style LISP expression containing
  TASK DEFINITION Ids and SUB DEPENDENCY Ids, grouped with the following
  operators:

    *  parallel scheduled operator
    +  sequenced scheduled operator

  Example (Assume 6 existing tasks labeled A through F):

    = (* A (+ B (* C D) A E) F)

  The above will run A and F in parallel along with the middle group
  (+ B (* C D) E A).  The middle group runs sequentally B followed by (* C D),
  where C and D run in parallel, and finally E with A already having run.

  TASK DEFINITION Ids can be used more than once in the tree but will only
  run one.  SUB DEPENDENCY ids can be used more than once as well with the
  tasks only being run once as well.


COMMAND LINE EXAMPLES

echo -e "a echo hello\nb echo world\n= (* a b)" | plize

./plize <<<'
a echo hello
b echo world
(* a b)
'

cat >specfile <<HEREDOC
(+ c (* a b))
a echo hello
b echo world
c echo ok
HEREDOC
./plize -c 8 -vv -o script.sh -l log.out specfile
./script.sh
cat log.out

BLOCK
}

function readTasksAndGraph () {
    declare -A treeLeafs # For asserting all tasks are in dependency tree
    local key value tokens
    while read -r key value
    do
      case "${key:0:1}" in
        ('' | '#')  ;;
        ('(')       [ "$topsexpr" ] && throwDependencyCollision || topsexpr+="$key $value" ;;
        ('*' | '+') throwInvalidTaskId ;;
        ('=') [ "${dependencies[$key]}" ] && throwDependencyCollision || dependencies+=($key $value) ;;
        (*) tasks[$key]=$value
            taskStates[$key]=ready
            tasksTimeStarted[$key]=0
            ;;
      esac
    done

    if [ "$topdependency" ]
    then
      local token=$topdependency
      [ "${dependencies[$token]}" ] || throwDependencyUnknown 
      sexpr2tokens <<<${dependencies[$token]}
      tokens2graph 0 <<<$tokens
      # No task coverage check when overriding top dependency tree
    else
      sexpr2tokens <<<$topsexpr
      tokens2graph 0 <<<$tokens
      # Verify all tasks in dependency tree
      unset treeLeafs[+] treeLeafs['"*"'] # Remove ops
      (( ${#treeLeafs[*]} == ${#tasks[*]} )) || throwDependencyGraph
    fi

}

function sexpr2tokens () {
    local c IFS=
    while read -r -n 1 c
    do case $c in
        ("("|")") tokens+=$'\n'$c$'\n' ;;
        (" "|$'\t') tokens+=$'\n';;
        (*) tokens+=$c ;;
    esac done
    tokens=${tokens#*(} # ignore first paren, presume parsing a list
}

function tokens2graph () {
    local token idx=$1 idxNext
    while read -r token
    do
      case $token in
        ('(') idxNext="${#dependencytree[*]}"
              dependencytree[idx]+="$idxNext "
              tokens2graph $idxNext
              ;;
        (')') return ;;
        ("") ;;
        (*) if [ "${token:0:1}" == "=" ]
            then
              [ "${dependencies[$token]}" == "" ] && throwDependencyUnknown 
              [ "${dependencies[$token]:0:1}" == "#" ] && throwDependencyCycle 
              local tokens
              sexpr2tokens <<<${dependencies[$token]}
              idxNext="${#dependencytree[*]}"
              dependencytree[$idx]+="$idxNext "
              dependencies[$token]="#${dependencies[$token]}" # set loop detection sentinel
              tokens2graph $idxNext <<<$tokens # parser recursion
              dependencies[$token]="${dependencies[$token]:1}" # unset sentinel
            else
              treeLeafs[$token]="" # keep track of used tasks
              dependencytree[$idx]+="$token "
            fi
            ;;
      esac
    done
}

########################################

function createScript () {
    {
      printf '#!/bin/bash\n'
      printf 'function main () {\nlocal -\nset +e +m -f\n'
      declare -p NORM RED GREEN YELLOW CYAN IRED IGREEN IBLUE ICYAN IMAGENTA WHITE quiet debug cpus logfile topdependency tasks taskStates tasksTimeStarted dependencies topsexpr dependencytree
      printf 'scheduler\n}\n'
      declare -f scheduler spawnNextFree spawnTask waitForATask prettyPrintEverything _prettyPrintEverything prettyPrintGraph _prettyPrintGraph reportTaskFail reportSpawned reportWaitingOnPid reportTaskCompleted throwUnknownOp 
      echo main
    } > $outputscript
    chmod u+x $outputscript
}

########################################

function scheduler () {
    local pid2task=() errnum=0
    ((debug)) && prettyPrintEverything
    while ((${#pid2task[*]} < cpus)) && spawnNextFree 0; do :; done
    while waitForATask
    do
        while ((${#pid2task[*]} < cpus)) && spawnNextFree 0; do :; done
    done
    ((debug)) && prettyPrintEverything
    return $errnum
}

function spawnNextFree () {
    if [ "${1//[0-9]}" == "" ]
    then
        local depth=$1 taskId allFinished=1
        case ${dependencytree[depth]%% *} in
        ("*")
            for taskId in ${dependencytree[depth]#* }
            do
              spawnNextFree $taskId
                case $? in
                    (0) return 0 ;;
                    (2) ;;
                    (*) allFinished=0 ;;
                esac
            done
            return $((allFinished ? 2 : 1))
            ;;
        ("+")
            for taskId in ${dependencytree[depth]#* }
            do
                spawnNextFree $taskId
                case $? in
                    (2) ;;
                    (*) return $? ;;
                esac
            done
            return 2
            ;;
        (*) throwUnknownOp ;;
        esac

    else
        local taskId=$1
        case ${taskStates[$taskId]} in
            (ready) spawnTask; return 0 ;;
            (running) return 1 ;;
            (finished) return 2 ;;
            (failed|*) return 3 ;;
        esac
    fi
}

function spawnTask () {
    local taskCmd="${tasks[$taskId]}"
    if ((quiet))
    then
        eval "$taskCmd" &
    else
        eval "{ $taskCmd ; } \
        2> >(while read -r l; do echo   \"$RED[$BASHPID:$taskId]$NORM \$l\"; done) \
        1> >(while read -r l; do echo \"$GREEN[$BASHPID:$taskId]$NORM \$l\"; done)" \
        &
    fi

    pid2task[$!]=$taskId
    taskStates[$taskId]=running
    tasksTimeStarted[$taskId]=$SECONDS
    ((debug)) && reportSpawned
    return 0
}

function waitForATask () {
    local pid taskId taskCmd start runtime
    ((${#pid2task[@]})) || return 255

    ((debug)) && reportWaitingOnPid

    wait -p pid -n ${!pid2task[@]}

    errnum=$?
    taskId=${pid2task[$pid]}
    taskCmd=${tasks[$taskId]}
    unset pid2task[$pid]
    start=${tasksTimeStarted[$taskId]}
    runtime=$((SECONDS-start))

    if ((errnum))
    then
        taskStates[$taskId]=failed
        reportTaskFail
        return $errnum
    else
        taskStates[$taskId]=finished
        ((debug)) && reportTaskCompleted
        return 0
    fi
}

########################################

function prettyPrintEverything () {
    [ "$logfile" ] && _prettyPrintEverything >>$logfile || _prettyPrintEverything
    prettyPrintGraph
}

function _prettyPrintEverything () {
    echo -e "${WHITE}--TASKS--------$NORM"
    for k in $(sort <(tr \  \\n <<<${!tasks[@]}))
    do
        echo " $GREEN$k $YELLOW${taskStates[$k]} $NORM${tasks[$k]}"
    done
    if (( ${#dependencies[*]} ))
    then
      echo -ne "${WHITE}SUB DEPENDENCIES$NORM\n"
      for k in ${!dependencies[*]}
      do
        printf " $k ${dependencies[$k]}\n"
      done
      printf " $topsexpr\n" 
    fi
    echo -ne "${WHITE}DEPENDENCY TREE$NORM\n "
}

function prettyPrintGraph () {
    local s=$(_prettyPrintGraph 0)
    [ "$logfile" ] && echo "$s" >>$logfile || echo "$s"
}

function _prettyPrintGraph () {
    if [ "${1//[0-9]}" == "" ]
    then
        local a w=""
        printf "("
        for a in ${dependencytree[$1]}
        do
            printf "$w"
            _prettyPrintGraph $a
            w=" "
        done
        printf ")"
    else
        case ${taskStates[$1]} in
            (ready) printf "$1" ;;
            (running) printf "$IGREEN$1$NORM" ;;
            (finished) printf "$IBLUE$1$NORM" ;;
            (failed) printf "$IRED$1$NORM" ;;
            (*) printf "$1" ;;
        esac
    fi
}

function reportTaskFail () {
    local s=s
    local b="$IRED[Exception pid $pid:$taskId returned $errnum ${runtime} sec${s:0:runtime!=1}]$NORM $taskCmd"
    [ "$logfile" ] && echo "$b" >>$logfile || echo "$b"
}

function reportSpawned () {
    local s="$IMAGENTA[Spawned $!:$taskId]$NORM $taskCmd"
    [ "$logfile" ] && echo "$s" >>$logfile || echo "$s"
}

function reportWaitingOnPid () {
    local all=""
    for p in ${!pid2task[*]}
    do
        all+=" $p:${pid2task[$p]}"
    done
    local s=$(
        echo -n "$IMAGENTA[Waiting on ${#pid2task[@]} $all]$NORM "
        local logfile=
        ((2 <= debug)) && prettyPrintGraph
    )
    [ "$logfile" ] && echo $s >>$logfile || echo $s
}

function reportTaskCompleted () {
    local s=s
    local b=$(
      echo -n "$IGREEN[Completed $pid:$taskId ${runtime} sec${s:0:runtime!=1}]$NORM $taskCmd "
      local logfile=
      ((2 <= debug)) && prettyPrintGraph
    )
    [ "$logfile" ] && echo $b >>$logfile || echo $b
}

########################################

function throwInvalidFile () {
    local s="$IRED[Exception invalid file: $specfile]$NORM"
    [ "$logfile" ] && echo $s >>$logfile || echo $s
    exit 2
}

function throwInvalidTaskId () {
    local s="$IRED[EXCEPTION task definition invalid key]$NORM $key $value"
    [ "$logfile" ] && echo $s >>$logfile || echo $s
    exit 3
}

function throwDependencyGraph () {
    local s="$IRED[EXCEPTION dependency tree missing one or more tasks]$NORM"
    [ "$logfile" ] && echo $s >>$logfile || echo $s
    prettyPrintEverything
    exit 4
}

function throwUnknownOp () {
    local s="$IRED[EXCEPTION unknown operator '${dependencytree[depth]%% *}'] $NORM"
    [ "$logfile" ] && printf "$s" >>$logfile || printf "$s"
    prettyPrintGraph
    exit 5
}

function throwDependencyCollision () {
    local s="$IRED[EXCEPTION dependency collision '$key $value'] $NORM\n"
    [ "$logfile" ] && printf "$s" >>$logfile || printf "$s"
    exit 6
}

function throwDependencyCycle () {
    local s="$IRED[EXCEPTION dependency cycle '$token ${dependencies[$token]}'] $NORM\n"
    [ "$logfile" ] && printf "$s" >>$logfile || printf "$s"
    exit 7
}

function throwDependencyUnknown () {
    local s="$IRED[EXCEPTION dependency not found '$token'] $NORM\n"
    [ "$logfile" ] && printf "$s" >>$logfile || printf "$s"
    exit 8
}

main "$@"
