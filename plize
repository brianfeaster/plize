#!/bin/bash

function main () {
    local -
    set +e +m -f
    local NORM RED GREEN YELLOW CYAN IRED IGREEN IBLUE ICYAN IMAGENTA WHITE
    local help=0
    local dryrun=0
    local quiet=0
    local debug=0
    declare -i cpus=2
    local specfile=""
    local logfile=""
    local outputscript=""

    parseCommandArgs "$*"
    [ "$logfile" ] || setColors

    ((help)) && help && return
    [ "$specfile" ] && { [ -e "$specfile" ] && exec <$specfile || throwInvalidFile; }

    declare -A tasks=()
    declare -A taskStates=()
    declare -A taskStart=()
    local dependencytree=("* ")
    readTasksAndGraph

    ((dryrun)) && return || {
        if [ "$outputscript" ]
        then
          createScript
        else
          scheduler
        fi
    }
}

########################################

function setColors () {
    NORM=$'\e[m'
    RED=$'\e[0;31m'
    GREEN=$'\e[0;32m'
    YELLOW=$'\e[0;33m'
    CYAN=$'\e[0;36m'
    IRED=$'\e[1;31m'
    IGREEN=$'\e[1;32m'
    IBLUE=$'\e[1;34m'
    ICYAN=$'\e[1;36m'
    IMAGENTA=$'\e[1;35m'
    WHITE=$'\e[1;37m'
}

function parseCommandArgs () {
    local a
    while read a
    do case $a in
      (-h) help=1 ;;
      (-d) dryrun=1 ;;
      (-q) quiet=1 ;;
      (-v) debug=1 ;;
      (-vv) debug=2 ;;
      (-c) read cpus ;;
      (-l) read logfile ;;
      (-o) read outputscript ;;
      (*) [ a[0] != - ] && specfile=$a ;;
    esac done < <(tr " " "\n" <<<$*)
}

function help () {
    cat <<BLOCK

NAME
  Parallelize - Dependency defined bash scheduler

USAGE
  plize [-h] [-c CPUs] [-d] [-q] [-v | -vv] [-l log] [-o ofile] [file]

  Reads Tasks and Dependency Specification via STDIN if no [file] specified.

  Returns 0 if all tasks succeed or the error number of the failing task.
  The scheduler stops if any task fails but will not stop any already
  running tasks.

OPTIONS
  -h       Help/manual
  -c       CPU/threads/process limit
  -d       Dry run
  -q       Quiet prefixed task info for all job output
  -v       Verbose runtime details
  -vv      Verbose plus dependency tree details
  -l       Logfile verbose messages are appended
  -o ofile Write a standalone runable script to ofile
  file     specification file

TASKS AND DEPENDENCIES FILE:

  The specifcation file contains multiple lines of "task definitions" and
  "dependency definitions."

  Examples:

task1 echo hello world
task2 git clone stuff; sleep && date
task3 cargo build | cat -n
= (* task1 (+ task2 task3))

aa echo hello
bb echo world
= (+ aa bb)
cc echo done
= (* aa cc)


TASK DEFINITION SYNTAX:

    taskId bash-expression

  A task definition consists of a unique task ID followed by a bash expression.
  The bash-expression must be one line with no line breaks.  It may be
  a compound expression IE with semicolons, pipes, etc.

  The task IDs are used in the dependency tree definitions.

  Example:

    task1 sleep 1; echo hello world | xxd

DEPENDENCY DEFINITION SYNTAX:

    = sexpr

  A parenthesized prefix-style LISP expression (prefixed by a "=") containing
  task Ids (specified via task definitions) and the following "operators":

    *  parallel scheduled operator
    +  sequenced scheduled operator

  Example (Assume 6 existing tasks labeled A through F):

    = (* A (+ B (* C D) A E) F)

  The above will run A and F in parallel along with the middle group
  (+ B (* C D) E A).  The middle group runs sequentally B followed by (* C D),
  where C and D run in parallel, and finally E with A already having run.

  TaskIDs can be used more than once in the tree but will only run one.

  Mutliple dependency definitions are considered parallel tasks. IE

    = (+ a b)
    = c

  is equivalent to

    = (* (+ a b) c)


COMMAND LINE EXAMPLES

echo -e "a echo hello\nb echo world\n= (* a b)" | plize

./plize <<<'
a echo hello
b echo world
= a
= b
'

cat >spec <<HEREDOC
= (+ c (* a b))
a echo hello
b echo world
c echo ok
HEREDOC
./plize -c 8 -vv spec

BLOCK
}

function readTasksAndGraph () {
    declare -A graphTasks
    local key value sexpr="" tokens
    while read -r key value
    do case $key in
        ("") ;;
        (=) sexpr+=" $value" ;;
        ("*"|"+") throwInvalidTaskId ;;
        (*) tasks[$key]=$value
            taskStates[$key]=ready
            taskStart[$key]=0
            ;;
        esac done
    sexpr2tokens <<<$sexpr
    tokens2graph 0 <<<$tokens
    unset graphTasks[+] graphTasks['"*"']
    (( ${#graphTasks[*]} == ${#tasks[*]})) || throwDependencyGraph
}

function sexpr2tokens () {
    local c IFS=
    while read -r -n 1 c
    do case $c in
        ("("|")") tokens+=$'\n'$c$'\n' ;;
        (" "|$'\t') tokens+=$'\n';;
        (*) tokens+=$c ;;
    esac done
}

function tokens2graph () {
    local task depth=$1
    while read -r task
    do
      case $task in
        ('(')
            dependencytree[depth]+="$((1+depth)) "
            tokens2graph $((depth+1))
            ;;
        (')') return ;;
        ("") ;;
        (*) graphTasks[$task]=
            dependencytree[depth]+="$task "
            ;;
      esac
    done
}

########################################

function createScript () {
    {
      printf '#!/bin/bash\n'
      printf 'function main () {\nlocal -\nset +e +m -f\n'
      declare -p NORM RED GREEN YELLOW CYAN IRED IGREEN IBLUE ICYAN IMAGENTA WHITE quiet debug cpus logfile tasks taskStates taskStart dependencytree
      printf 'scheduler\n}\n'
      declare -f scheduler spawnNextFree spawnTask waitForATask prettyPrintEverything _prettyPrintEverything prettyPrintGraph _prettyPrintGraph reportTaskFail reportSpawned reportWaitingOnPid reportTaskCompleted throwUnknownDependency 
      echo main
    } > $outputscript
    chmod u+x $outputscript
}

########################################

function scheduler () {
    local pid2task=() errnum=0
    ((debug)) && prettyPrintEverything
    while ((${#pid2task[*]} < cpus)) && spawnNextFree 0; do :; done
    while waitForATask
    do
        while ((${#pid2task[*]} < cpus)) && spawnNextFree 0; do :; done
    done
    ((debug)) && prettyPrintEverything
    return $errnum
}

function spawnNextFree () {
    if [ "${1//[0-9]}" == "" ]
    then
        local depth=$1 taskId allFinished=1
        case ${dependencytree[depth]%% *} in
        ("*")
            for taskId in ${dependencytree[depth]#* }
            do
              spawnNextFree $taskId
                case $? in
                    (0) return 0 ;;
                    (2) ;;
                    (*) allFinished=0 ;;
                esac
            done
            return $((allFinished ? 2 : 1))
            ;;
        ("+")
            for taskId in ${dependencytree[depth]#* }
            do
                spawnNextFree $taskId
                case $? in
                    (2) ;;
                    (*) return $? ;;
                esac
            done
            return 2
            ;;
        (*)
            throwUnknownDependency
            exit 4 ;;
        esac

    else
        local taskId=$1
        case ${taskStates[$taskId]} in
            (ready) spawnTask; return 0 ;;
            (running) return 1 ;;
            (finished) return 2 ;;
            (failed|*) return 3 ;;
        esac
    fi
}

function spawnTask () {
    local taskCmd="${tasks[$taskId]}"
    if ((quiet))
    then
        eval "$taskCmd" &
    else
        eval "{ $taskCmd ; } \
        2> >(while read -r l; do echo   \"$RED[$BASHPID:$taskId]$NORM \$l\"; done) \
        1> >(while read -r l; do echo \"$GREEN[$BASHPID:$taskId]$NORM \$l\"; done)" \
        &
    fi

    pid2task[$!]=$taskId
    taskStates[$taskId]=running
    taskStart[$taskId]=$SECONDS
    ((debug)) && reportSpawned
    return 0
}

function waitForATask () {
    local pid taskId taskCmd start runtime
    ((${#pid2task[@]})) || return 255

    ((debug)) && reportWaitingOnPid

    wait -p pid -n ${!pid2task[@]}

    errnum=$?
    taskId=${pid2task[$pid]}
    taskCmd=${tasks[$taskId]}
    unset pid2task[$pid]
    start=${taskStart[$taskId]}
    runtime=$((SECONDS-start))

    if ((errnum))
    then
        taskStates[$taskId]=failed
        reportTaskFail
        return $errnum
    else
        taskStates[$taskId]=finished
        ((debug)) && reportTaskCompleted
        return 0
    fi
}

########################################

function prettyPrintEverything () {
    [ "$logfile" ] && _prettyPrintEverything >>$logfile || _prettyPrintEverything
    prettyPrintGraph
}

function _prettyPrintEverything () {
    echo -e "${WHITE}--TASKS--------$NORM"
    for k in $(sort <(tr \  \\n <<<${!tasks[@]}))
    do
        echo " $GREEN$k $YELLOW${taskStates[$k]} $NORM${tasks[$k]}"
    done
    echo -ne "${WHITE}TREE$NORM\n "
}

function prettyPrintGraph () {
    local s=$(_prettyPrintGraph 0)
    [ "$logfile" ] && echo "$s" >>$logfile || echo "$s"
}

function _prettyPrintGraph () {
    if [ "${1//[0-9]}" == "" ]
    then
        local a w="("
        for a in ${dependencytree[$1]}
        do
            printf "$w"
            _prettyPrintGraph $a
            w=" "
        done
        printf ")"
    else
        case ${taskStates[$1]} in
            (ready) printf "$1" ;;
            (running) printf "$IGREEN$1$NORM" ;;
            (finished) printf "$IBLUE$1$NORM" ;;
            (failed) printf "$IRED$1$NORM" ;;
            (*) printf "$1" ;;
        esac
    fi
}

function reportTaskFail () {
    local s=s
    let b="$IRED[Exception pid $pid:$taskId returned $errnum ${runtime} sec${s:0:runtime!=1}]$NORM $taskCmd"
    [ "$logfile" ] && echo "$b" >>$logfile || echo "$b"
}

function reportSpawned () {
    local s="$IMAGENTA[Spawned $!:$taskId]$NORM $taskCmd"
    [ "$logfile" ] && echo "$s" >>$logfile || echo "$s"
}

function reportWaitingOnPid () {
    local all=""
    for p in ${!pid2task[*]}
    do
        all+=" $p:${pid2task[$p]}"
    done
    local s=$(
        echo -n "$IMAGENTA[Waiting on ${#pid2task[@]} $all]$NORM "
        local logfile=
        ((2 <= debug)) && prettyPrintGraph
    )
    [ "$logfile" ] && echo $s >>$logfile || echo $s
}

function reportTaskCompleted () {
    local s=s
    local b=$(
      echo -n "$IGREEN[Completed $pid:$taskId ${runtime} sec${s:0:runtime!=1})]$NORM $taskCmd "
      local logfile=
      ((2 <= debug)) && prettyPrintGraph
    )
    [ "$logfile" ] && echo $b >>$logfile || echo $b
}

########################################

function throwInvalidFile () {
    local s="$IRED[Exception invalid file: $specfile]$NORM"
    [ "$logfile" ] && echo $s >>$logfile || echo $s
    exit 2
}

function throwInvalidTaskId () {
    local s="$IRED[EXCEPTION task definition invlaid key]$NORM $key $value"
    [ "$logfile" ] && echo $s >>$logfile || echo $s
    exit 3
}

function throwDependencyGraph () {
    local s="$IRED[EXCEPTION dependency tree missing one or more tasks]$NORM"
    [ "$logfile" ] && echo $s >>$logfile || echo $s
    prettyPrintEverything
    exit 4
}

function throwUnknownDependency () {
    local s="$IRED[EXCEPTION unknown dependency op '$p'] $NORM"
    [ "$logfile" ] && printf "$s" >>$logfile || printf "$s"
    prettyPrintGraph
}

main "$@"
